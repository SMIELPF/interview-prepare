### 位置符
- `^`: 匹配字符串开头的位置
- `$`: 匹配字符串结尾的位置
- `\b`: 匹配一个单词边界，即字与空格间的位置
- `\B`: 匹配非单词边界

### 占位符
- `[xyz]`: 匹配字符集合，例如，[abc]能匹配上plaint中的a
- `[^xyz]`: 匹配非字符集合，只要字符不在字符集合中，就能匹配
- `\d`: 匹配一个数字，相当于`[0-9]`
- `\D`: 匹配一个非数字, 相当于`[^0-9]`
- `\w`: 匹配字母、数字、下划线, 相当于`[0-9a-zA-Z_]`
- `\W`: 匹配非字母、数字、下划线, 相当于`[^0-9a-zA-Z_]`
- `\s`: 匹配空白符，包括空格、制表符、换页符等等，相当于 `[\f\n\r\t\v]`
- `\S`: 匹配非空白符，相当于`[^\f\n\r\t\v]`
- `.`: 匹配除了换行符外的任意字符
- `pattern1|pattern2`: 匹配pattern1或pattern2

### 子表达式
**捕获分组：** 会把括号中的匹配到的子字符串存放到内置变量`$1`, `$2`, `$3` ...中
**非捕获分组：** 只负责匹配子表达式，而不会暂存匹配到的子字符串，也就不占用内置索引`$1`, `$2` ...
> 例子：
要在一篇文章中查找"program"和"project"两个单词，正则表达式可表示为/program|project/,也可表示为/pro(gram|ject)/，但是缓存子匹配(gramject)没有意义，就可以用/pro(?:gram|ject)/进行非捕获性匹配这样既可以简洁匹配又可不缓存无实际意义的字匹配。

- `(pattern)`: 捕获分组的子匹配；`/windows(98|XP|7)/`可以匹配字符串`this is windows98`中的`windows98`, 且`98`被暂存到内置变量`$1`
- `(?:pattern)`: 不捕获分组的子匹配； `/windows(?:98|XP|7)/`可以匹配字符串`this is windows98`中的`windows98`, 且不暂存任何子匹配
- `(?=pattern)`: 正向肯定预查，是不捕获分组； `/windows(?=98|XP|7)/`可以匹配字符串`this is windows98`中的`windows`, 不可以匹配`windows10`中的`windows`, 且不暂存任何子匹配
- `(?!pattern)`: 正向否定预查，是不捕获分组；`/window(?!98|XP|7)/`可以匹配字符串`this is windows10`中的`windows`, 不能匹配`windows7`中的windows，且不暂存任何子匹配
- `(?<=)`: 反向肯定预查，是不捕获分组；`/(?<=98|XP|7)windows/`可以匹配字符串`this is 98windows`中的`windows`, 不能匹配`10windows`中的`windows`, 且不暂存任何子匹配
- `(?<!)`: 反向否定预查, 是不捕获分组；`/(?<！98|XP|7)windows/`可以匹配字符串`this is 10windows`中的`windows`, 不能匹配`98windows`中的`windows`, 且不暂存任何子匹配

### 限定符
- `{n}`: 匹配前面的占位符或子表达式n次
- `{n,}`: 匹配前面的占位符或子表达式n到多次
- `{n, m}`: 匹配前面的占位符或子表达式n到m次
- `+`: 匹配前面的占位符或子表达式一次或多次
- `*`: 匹配前面的占位符或子表达式零次或多次
- `?`: 匹配前面的占位符或子表达式零次或一次, 当`?`紧跟在任何一个其他限定符 `(*, +, ?, {n}, {n,}, {n,m})` 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。

